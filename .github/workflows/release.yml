# =============================================================================
# Release Workflow: kvm-over-ip Binary Release and Installer Packages
# =============================================================================
#
# PURPOSE:
#   This workflow fires when a version tag (e.g., v1.2.3) is pushed to the
#   repository.  It builds release-optimised binaries and installer packages
#   for Windows, Linux, and macOS, then creates a GitHub Release and attaches
#   all artefacts as downloadable assets.
#
# HOW TO TRIGGER A RELEASE:
#   From your local machine:
#     git tag v1.2.3
#     git push origin v1.2.3
#   GitHub Actions detects the new tag and starts this workflow.
#
# WHAT IS A "RELEASE BINARY"?
#   The `release` Cargo profile (defined in src/Cargo.toml) enables:
#     - opt-level 3 (maximum compiler optimisation)
#     - lto = true  (Link-Time Optimisation – further reduces binary size)
#     - codegen-units = 1 (allows more cross-function optimisation)
#     - strip = true  (removes debug symbols to reduce file size)
#
# BINARY AND INSTALLER TARGETS:
#   Platform     Binary                  Installer
#   ----------   ----------------------  -----------------------------------------
#   Windows      kvm-master.exe          kvm-master-<ver>.msi  (cargo-wix)
#                kvm-client.exe          kvm-client-<ver>.msi  (cargo-wix)
#                kvm-web-bridge.exe      (raw binary only)
#   Linux        kvm-client              kvm-client-<ver>-amd64.deb  (cargo-deb)
#                kvm-web-bridge          kvm-web-bridge-<ver>-amd64.deb (cargo-deb)
#   macOS        kvm-client              KVM-Over-IP-Client-<ver>.dmg (cargo-bundle)
#                kvm-web-bridge          (raw binary only)
#
# INSTALLER TOOLS:
#   cargo-wix   : Wraps WiX Toolset to build MSI packages on Windows.
#                 Reads [package.metadata.wix] from Cargo.toml.
#                 https://github.com/volks73/cargo-wix
#
#   cargo-deb   : Builds Debian .deb packages on Linux.
#                 Reads [package.metadata.deb] from Cargo.toml.
#                 https://github.com/kornelski/cargo-deb
#
#   cargo-bundle: Builds macOS .app bundles and other platform packages.
#                 Reads [package.metadata.bundle] from Cargo.toml.
#                 https://github.com/burtonageo/cargo-bundle
#
# CHANGELOG GENERATION:
#   The `softprops/action-gh-release` action automatically collects commit
#   messages since the previous tag and inserts them as the release body.
#
# PERMISSIONS:
#   The workflow needs `contents: write` to create the GitHub Release and
#   upload the binary assets.  The default `GITHUB_TOKEN` is used; no
#   additional secrets are required for unsigned builds.
#
# CODE SIGNING:
#   This workflow does NOT perform code signing.  To add code signing:
#     Windows: Store the PFX certificate as a GitHub Secret and pass
#              `-p` / `-k` flags to `cargo wix` or `signtool`.
#     macOS:   Store the Developer ID certificate in a GitHub Secret,
#              import it into a keychain, then pass `--sign` to codesign.
#   See docs/PACKAGING.md for detailed signing instructions.

name: Release

# ---------------------------------------------------------------------------
# TRIGGERS
# ---------------------------------------------------------------------------
# Only activate when a tag matching `v*.*.*` is pushed (semantic versioning).
on:
  push:
    tags:
      - 'v[0-9]+.[0-9]+.[0-9]+'

# Grant the built-in GITHUB_TOKEN permission to create releases and upload assets.
permissions:
  contents: write

defaults:
  run:
    shell: bash

# =============================================================================
# JOBS
# =============================================================================

jobs:

  # ---------------------------------------------------------------------------
  # JOB: build-windows
  # ---------------------------------------------------------------------------
  # Compiles Windows binaries and builds MSI installers for kvm-master and
  # kvm-client using cargo-wix.  The job also produces a raw binary ZIP
  # archive for users who prefer not to use the MSI installer.
  # ---------------------------------------------------------------------------
  build-windows:
    name: Build Windows — binaries + MSI installers
    runs-on: windows-latest

    steps:
      # Step 1: Check out the code at the tagged commit.
      - name: Check out repository
        uses: actions/checkout@v6

      # Step 2: Install the Rust stable toolchain.
      - name: Install Rust stable toolchain
        uses: dtolnay/rust-toolchain@stable

      # Step 3: Restore the Cargo registry cache to speed up dependency downloads.
      - name: Cache Cargo registry
        uses: actions/cache@v5
        with:
          path: |
            ~/.cargo/registry/index
            ~/.cargo/registry/cache
            ~/.cargo/git/db
          key: windows-cargo-registry-${{ hashFiles('src/**/Cargo.lock', 'src/Cargo.toml') }}
          restore-keys: |
            windows-cargo-registry-

      # Step 4: Build all crates in release mode.
      #   Platform-gated code (Win32 hooks) is included automatically by the
      #   Rust compiler because the host OS is Windows.
      - name: Build release binaries
        run: cargo build --manifest-path src/Cargo.toml --release --workspace

      # Step 5: Install cargo-wix for building MSI packages.
      #   cargo-wix is a cargo subcommand that wraps the WiX Toolset.
      #   It reads [package.metadata.wix] from each crate's Cargo.toml.
      #   WiX Toolset v3 is pre-installed on GitHub Windows runners.
      - name: Install cargo-wix
        run: cargo install cargo-wix --version "0.3" --locked

      # Step 6: Build the kvm-master MSI installer.
      #   --package kvm-master       : Build only the kvm-master crate's WiX config.
      #   --nocapture                : Print WiX compiler output to the workflow log.
      #   --no-build                 : Skip recompiling; we already built in Step 4.
      #
      # NOTE: cargo-wix expects a wix\main.wxs file in the crate directory.
      # It also expects the icon file at wix\kvm-master.ico.  If the icon does
      # not exist, the build will fail.  A placeholder must be provided or the
      # Icon element in main.wxs must be removed.
      - name: Build kvm-master MSI
        shell: bash
        run: |
          # Navigate into the src/ workspace where the crates live.
          cd src

          # cargo-wix reads the manifest from the specified package.
          # --no-build avoids a second compilation pass (we compiled in Step 4).
          cargo wix --package kvm-master --nocapture --no-build \
            || { echo "cargo-wix for kvm-master failed"; exit 1; }

      # Step 7: Build the kvm-client MSI installer.
      - name: Build kvm-client MSI
        shell: bash
        run: |
          cd src
          cargo wix --package kvm-client --nocapture --no-build \
            || { echo "cargo-wix for kvm-client failed"; exit 1; }

      # Step 8: Stage binaries and MSI files into a single dist directory.
      - name: Stage Windows release artefacts
        shell: bash
        run: |
          VERSION="${{ github.ref_name }}"
          STAGING="kvm-over-ip-${VERSION}-windows-x86_64"
          mkdir -p "${STAGING}"

          # Copy raw binaries into the staging directory.
          cp src/target/release/kvm-master.exe     "${STAGING}/"
          cp src/target/release/kvm-client.exe     "${STAGING}/"
          cp src/target/release/kvm-web-bridge.exe "${STAGING}/"
          cp README.md "${STAGING}/" 2>/dev/null || true

          # Find and copy the generated MSI files.
          # cargo-wix places MSIs in src/target/wix/*.msi
          find src/target/wix -name "*.msi" 2>/dev/null | while read msi; do
            cp "$msi" "${STAGING}/"
          done

          echo "STAGING=${STAGING}" >> "$GITHUB_ENV"

      # Step 9: Create a ZIP archive of the staging directory.
      - name: Create Windows archive (ZIP)
        shell: bash
        run: |
          ARCHIVE="${STAGING}.zip"
          powershell -Command "Compress-Archive -Path '${STAGING}' -DestinationPath '${ARCHIVE}'"
          echo "ARCHIVE=${ARCHIVE}" >> "$GITHUB_ENV"

      # Step 10: Upload the archive as a workflow artefact.
      - name: Upload Windows artefacts
        uses: actions/upload-artifact@v6
        with:
          name: release-windows-x86_64
          path: ${{ env.ARCHIVE }}
          if-no-files-found: error

      # Step 11: Upload MSI files as separate named artefacts for easy download.
      - name: Upload MSI installers as separate artefacts
        shell: bash
        run: |
          # List the MSIs we produced for logging purposes.
          find src/target/wix -name "*.msi" 2>/dev/null || echo "No MSI files found in src/target/wix"

      - name: Upload kvm-master MSI
        uses: actions/upload-artifact@v6
        with:
          name: installer-kvm-master-windows
          # cargo-wix names the MSI after the package with the version: kvm-master-<ver>-x86_64.msi
          path: src/target/wix/*.msi
          if-no-files-found: warn

  # ---------------------------------------------------------------------------
  # JOB: build-linux
  # ---------------------------------------------------------------------------
  # Compiles Linux binaries and builds Debian .deb packages for kvm-client
  # and kvm-web-bridge using cargo-deb.
  # ---------------------------------------------------------------------------
  build-linux:
    name: Build Linux — binaries + .deb packages
    runs-on: ubuntu-latest

    steps:
      - name: Check out repository
        uses: actions/checkout@v6

      - name: Install Rust stable toolchain
        uses: dtolnay/rust-toolchain@stable

      # Install X11/XTest development libraries required to compile kvm-client.
      # These packages must be present for the linker to find libx11 and libxtst.
      - name: Install Linux system dependencies
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y --no-install-recommends \
            libx11-dev \
            libxtst-dev

      - name: Cache Cargo registry
        uses: actions/cache@v5
        with:
          path: |
            ~/.cargo/registry/index
            ~/.cargo/registry/cache
            ~/.cargo/git/db
          key: linux-cargo-registry-${{ hashFiles('src/**/Cargo.lock', 'src/Cargo.toml') }}
          restore-keys: |
            linux-cargo-registry-

      # Build all crates.  kvm-master is compiled here too (for correctness
      # checking) even though it is Windows-only — Rust simply excludes the
      # Win32 hook code on Linux.
      - name: Build release binaries
        run: cargo build --manifest-path src/Cargo.toml --release --workspace

      # Install cargo-deb.
      # cargo-deb reads [package.metadata.deb] from Cargo.toml and produces
      # a proper .deb package including maintainer scripts and service files.
      # Install cargo-deb without a version pin so the latest stable release is used.
      # If you need a reproducible pin, replace with e.g. --version "2.1.0".
      - name: Install cargo-deb
        run: cargo install cargo-deb --locked

      # Build the kvm-client .deb package.
      # --no-build: skip recompilation (already built above).
      # --manifest-path: path to the workspace Cargo.toml.
      - name: Build kvm-client .deb package
        run: |
          cargo deb \
            --manifest-path src/Cargo.toml \
            --package kvm-client \
            --no-build \
            || { echo "cargo-deb for kvm-client failed"; exit 1; }

      # Build the kvm-web-bridge .deb package.
      - name: Build kvm-web-bridge .deb package
        run: |
          cargo deb \
            --manifest-path src/Cargo.toml \
            --package kvm-web-bridge \
            --no-build \
            || { echo "cargo-deb for kvm-web-bridge failed"; exit 1; }

      # Stage all artefacts.
      - name: Stage Linux release artefacts
        run: |
          VERSION="${{ github.ref_name }}"
          STAGING="kvm-over-ip-${VERSION}-linux-x86_64"
          mkdir -p "${STAGING}"

          # Raw binaries.
          cp src/target/release/kvm-master     "${STAGING}/" 2>/dev/null || true
          cp src/target/release/kvm-client     "${STAGING}/"
          cp src/target/release/kvm-web-bridge "${STAGING}/"
          cp README.md "${STAGING}/" 2>/dev/null || true

          # .deb packages: cargo-deb places them in src/target/debian/
          find src/target/debian -name "*.deb" 2>/dev/null | while read deb; do
            cp "$deb" "${STAGING}/"
          done

          echo "STAGING=${STAGING}" >> "$GITHUB_ENV"

      - name: Create Linux archive (tar.gz)
        run: |
          tar -czf "${STAGING}.tar.gz" "${STAGING}"
          echo "ARCHIVE=${STAGING}.tar.gz" >> "$GITHUB_ENV"

      - name: Upload Linux artefacts
        uses: actions/upload-artifact@v6
        with:
          name: release-linux-x86_64
          path: ${{ env.ARCHIVE }}
          if-no-files-found: error

      # Upload .deb files as separate named artefacts.
      - name: Upload .deb packages as separate artefacts
        uses: actions/upload-artifact@v6
        with:
          name: installer-linux-deb
          path: src/target/debian/*.deb
          if-no-files-found: warn

  # ---------------------------------------------------------------------------
  # JOB: build-macos
  # ---------------------------------------------------------------------------
  # Compiles macOS binaries and builds a .app bundle + .dmg disk image for
  # kvm-client using cargo-bundle and the create-dmg.sh script.
  # ---------------------------------------------------------------------------
  build-macos:
    name: Build macOS — binaries + .app/.dmg
    runs-on: macos-latest

    steps:
      - name: Check out repository
        uses: actions/checkout@v6

      - name: Install Rust stable toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Cache Cargo registry
        uses: actions/cache@v5
        with:
          path: |
            ~/.cargo/registry/index
            ~/.cargo/registry/cache
            ~/.cargo/git/db
          key: macos-cargo-registry-${{ hashFiles('src/**/Cargo.lock', 'src/Cargo.toml') }}
          restore-keys: |
            macos-cargo-registry-

      # Build release binaries.
      - name: Build release binaries
        run: cargo build --manifest-path src/Cargo.toml --release --workspace

      # Install cargo-bundle for .app creation.
      - name: Install cargo-bundle
        run: cargo install cargo-bundle --locked

      # Build the kvm-client .app bundle.
      # cargo-bundle reads [package.metadata.bundle] from Cargo.toml.
      - name: Build kvm-client .app bundle
        run: |
          cd src
          cargo bundle --release --package kvm-client \
            || { echo "cargo-bundle for kvm-client failed"; exit 1; }

      # Inject the custom Info.plist into the bundle with version substitution.
      - name: Inject Info.plist into .app bundle
        run: |
          VERSION="${{ github.ref_name }}"
          # Remove the leading "v" from the tag name (e.g., v1.2.3 → 1.2.3).
          APP_VERSION="${VERSION#v}"
          SHORT_VERSION=$(echo "${APP_VERSION}" | cut -d. -f1-2)

          BUNDLE_PATH="src/target/release/bundle/osx/KVM-Over-IP Client.app"

          # Substitute template variables in our custom Info.plist.
          sed \
            -e "s/{{BUNDLE_VERSION}}/${APP_VERSION}/g" \
            -e "s/{{SHORT_VERSION}}/${SHORT_VERSION}/g" \
            build/macos/Info.plist \
            > "${BUNDLE_PATH}/Contents/Info.plist"

          echo "Info.plist injected successfully."

      # Create the .dmg using hdiutil (create-dmg tool is not installed by default).
      # We use hdiutil create -srcfolder for macOS 15+ compatibility.
      - name: Create .dmg disk image
        run: |
          VERSION="${{ github.ref_name }}"
          APP_VERSION="${VERSION#v}"
          DMG_NAME="kvm-over-ip-${APP_VERSION}-macos"
          BUNDLE_PATH="src/target/release/bundle/osx/KVM-Over-IP Client.app"

          mkdir -p dist/macos
          FINAL_DMG="dist/macos/${DMG_NAME}.dmg"

          # Stage the .app bundle and an Applications symlink into a temp folder.
          STAGING_DIR="$(mktemp -d)"
          cp -R "${BUNDLE_PATH}" "${STAGING_DIR}/"
          ln -s /Applications "${STAGING_DIR}/Applications"

          # Create a compressed read-only DMG directly from the staging folder.
          hdiutil create \
            -volname "KVM-Over-IP ${APP_VERSION}" \
            -srcfolder "${STAGING_DIR}" \
            -ov \
            -format UDZO \
            "${FINAL_DMG}"

          rm -rf "${STAGING_DIR}"

          echo "DMG created: ${FINAL_DMG}"
          echo "DMG_PATH=${FINAL_DMG}" >> "$GITHUB_ENV"
          echo "APP_VERSION=${APP_VERSION}" >> "$GITHUB_ENV"

      # Stage all macOS artefacts into a single archive for the release job.
      - name: Stage macOS release artefacts
        run: |
          VERSION="${{ github.ref_name }}"
          STAGING="kvm-over-ip-${VERSION}-macos-aarch64"
          mkdir -p "${STAGING}"

          # Raw binaries.
          cp src/target/release/kvm-client     "${STAGING}/"
          cp src/target/release/kvm-web-bridge "${STAGING}/"
          cp README.md "${STAGING}/" 2>/dev/null || true

          # Copy the DMG into the staging directory.
          cp "${DMG_PATH}" "${STAGING}/"

          echo "STAGING=${STAGING}" >> "$GITHUB_ENV"

      - name: Create macOS archive (tar.gz)
        run: |
          tar -czf "${STAGING}.tar.gz" "${STAGING}"
          echo "ARCHIVE=${STAGING}.tar.gz" >> "$GITHUB_ENV"

      - name: Upload macOS artefacts
        uses: actions/upload-artifact@v6
        with:
          name: release-macos-aarch64
          path: ${{ env.ARCHIVE }}
          if-no-files-found: error

      # Upload the .dmg as a separate named artefact for easy direct download.
      - name: Upload .dmg as separate artefact
        uses: actions/upload-artifact@v6
        with:
          name: installer-macos-dmg
          path: dist/macos/*.dmg
          if-no-files-found: warn

  # ---------------------------------------------------------------------------
  # JOB: create-github-release
  # ---------------------------------------------------------------------------
  # Downloads all platform artefacts from the build jobs and creates a GitHub
  # Release, attaching binary archives and installer packages as release assets.
  #
  # Why a separate job?
  #   The three build jobs run in parallel.  This final job uses `needs` to
  #   wait for all three to complete successfully before creating the release.
  #   This prevents a partial release from appearing if one platform fails.
  # ---------------------------------------------------------------------------
  create-github-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [build-windows, build-linux, build-macos]

    steps:
      - name: Check out repository (for changelog context)
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      # Download all platform archives from the build jobs.
      # The `pattern: release-*` matches all three archive artefacts.
      # `merge-multiple: true` places all files in a single `dist/` directory.
      - name: Download all platform archives
        uses: actions/download-artifact@v7
        with:
          pattern: release-*
          path: dist/
          merge-multiple: true

      # Download installer packages into a separate directory.
      - name: Download installer packages
        uses: actions/download-artifact@v7
        with:
          pattern: installer-*
          path: installers/
          merge-multiple: true

      # List all downloaded files for verification in the workflow log.
      - name: List release artefacts
        run: |
          echo "=== Binary Archives ===" && ls -lh dist/ || true
          echo "=== Installer Packages ===" && ls -lh installers/ || true

      # Create the GitHub Release and attach all artefacts.
      #
      # The release body is a hand-crafted table of downloads supplemented
      # by auto-generated release notes from commit messages.
      - name: Create GitHub Release and upload assets
        uses: softprops/action-gh-release@v2
        with:
          generate_release_notes: true
          body: |
            ## KVM-Over-IP ${{ github.ref_name }}

            ### Downloads — Binary Archives (raw binaries + README)

            | Platform      | Archive                                                       |
            |---------------|---------------------------------------------------------------|
            | Windows x64   | `kvm-over-ip-${{ github.ref_name }}-windows-x86_64.zip`      |
            | Linux x64     | `kvm-over-ip-${{ github.ref_name }}-linux-x86_64.tar.gz`     |
            | macOS arm64   | `kvm-over-ip-${{ github.ref_name }}-macos-aarch64.tar.gz`    |

            ### Downloads — Installers (recommended)

            | Platform      | Installer                                      | Tool       |
            |---------------|------------------------------------------------|------------|
            | Windows x64   | `kvm-master-*.msi` / `kvm-client-*.msi`        | cargo-wix  |
            | Linux x64     | `kvm-client_*.deb` / `kvm-web-bridge_*.deb`    | cargo-deb  |
            | macOS arm64   | `kvm-over-ip-*-macos.dmg`                      | hdiutil    |

            ### Quick Start

            1. **Master machine** (the machine with the physical keyboard/mouse):
               - Windows: install `kvm-master-*.msi` and run KVM-Over-IP Master
            2. **Client machine** (the machine that will receive forwarded input):
               - Windows: install `kvm-client-*.msi`
               - Linux: `sudo apt install ./kvm-client_*.deb`
               - macOS: open the `.dmg` and drag `KVM-Over-IP Client.app` to `/Applications`
            3. **Optional** — run `kvm-web-bridge` on the master machine to enable browser-based access.

            See `README.md` inside each archive for full setup instructions.

            ---
            *Auto-generated release notes from commits since previous tag:*
          # Upload everything from both the archives directory and the installers directory.
          files: |
            dist/*
            installers/*
          fail_on_unmatched_files: false
