# =============================================================================
# Release Workflow: kvm-over-ip Binary Release
# =============================================================================
#
# PURPOSE:
#   This workflow fires when a version tag (e.g., v1.2.3) is pushed to the
#   repository. It builds release-optimised binaries for Windows, Linux, and
#   macOS, then creates a GitHub Release and attaches the binaries as
#   downloadable assets.
#
# HOW TO TRIGGER A RELEASE:
#   From your local machine:
#     git tag v1.2.3
#     git push origin v1.2.3
#   GitHub Actions detects the new tag and starts this workflow.
#
# WHAT IS A "RELEASE BINARY"?
#   The `release` Cargo profile (defined in src/Cargo.toml) enables:
#     - opt-level 3 (maximum compiler optimisation)
#     - lto = true  (Link-Time Optimisation – further reduces binary size)
#     - codegen-units = 1 (allows more cross-function optimisation)
#     - strip = true  (removes debug symbols to reduce file size)
#
# BINARY TARGETS:
#   Platform     Binary name              Notes
#   ----------   -----------------------  ----------------------------------------
#   Windows      kvm-master.exe           Uses Win32 hooks (Windows-only crate)
#                kvm-client.exe
#                kvm-web-bridge.exe
#   Linux        kvm-master               kvm-master omits Windows hook code
#                kvm-client               Requires libX11 and libXtst at runtime
#                kvm-web-bridge
#   macOS        kvm-master               kvm-master omits Windows hook code
#                kvm-client               Uses CoreGraphics (built-in macOS SDK)
#                kvm-web-bridge
#
# CHANGELOG GENERATION:
#   The `softprops/action-gh-release` action automatically collects commit
#   messages since the previous tag and inserts them as the release body.
#
# PERMISSIONS:
#   The workflow needs `contents: write` to create the GitHub Release and
#   upload the binary assets. The default `GITHUB_TOKEN` is used; no
#   additional secrets are required.

name: Release

# ---------------------------------------------------------------------------
# TRIGGERS
# ---------------------------------------------------------------------------
# Only activate when a tag matching `v*.*.*` is pushed (semantic versioning).
# This prevents the release workflow from running on branch pushes or PRs.
# ---------------------------------------------------------------------------
on:
  push:
    tags:
      - 'v[0-9]+.[0-9]+.[0-9]+'

# Grant the built-in GITHUB_TOKEN permission to create releases and upload
# release assets. Without this, the upload step would receive a 403 error.
permissions:
  contents: write

defaults:
  run:
    shell: bash

# =============================================================================
# JOBS
# =============================================================================

jobs:

  # ---------------------------------------------------------------------------
  # JOB: build-release-binaries
  # ---------------------------------------------------------------------------
  # Compiles and packages release binaries for all three target platforms in
  # parallel. The matrix produces three independent jobs:
  #   - ubuntu-latest  → Linux x86-64 binaries
  #   - windows-latest → Windows x86-64 .exe binaries
  #   - macos-latest   → macOS arm64/x86-64 binaries (depends on runner image)
  # ---------------------------------------------------------------------------
  build-release-binaries:
    name: Build Release – ${{ matrix.os }}
    runs-on: ${{ matrix.os }}

    strategy:
      fail-fast: false
      matrix:
        include:
          # --- Linux ---
          # archive_ext: the file extension used for the uploaded archive.
          # binary_suffix: empty on Unix, ".exe" on Windows.
          - os: ubuntu-latest
            target_name: linux-x86_64
            archive_ext: tar.gz
            binary_suffix: ''

          # --- Windows ---
          - os: windows-latest
            target_name: windows-x86_64
            archive_ext: zip
            binary_suffix: .exe

          # --- macOS ---
          - os: macos-latest
            target_name: macos-aarch64
            archive_ext: tar.gz
            binary_suffix: ''

    steps:
      # Step 1: Check out the code at the tagged commit.
      - name: Check out repository
        uses: actions/checkout@v4

      # Step 2: Install the Rust stable toolchain.
      #   We use the same stable toolchain as CI to ensure consistency between
      #   CI test results and release binaries.
      - name: Install Rust stable toolchain
        uses: dtolnay/rust-toolchain@stable

      # Step 3 (Linux only): Install X11/XTest system libraries.
      #   The kvm-client Linux backend links against libX11 and libXtst.
      #   These system packages must be present for the linker to succeed.
      - name: Install Linux system dependencies (Ubuntu only)
        if: matrix.os == 'ubuntu-latest'
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y --no-install-recommends \
            libx11-dev \
            libxtst-dev

      # Step 4: Restore the Cargo registry cache.
      #   This prevents downloading all dependency crates on every release run.
      - name: Cache Cargo registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry/index
            ~/.cargo/registry/cache
            ~/.cargo/git/db
          key: ${{ runner.os }}-cargo-registry-${{ hashFiles('src/**/Cargo.lock', 'src/Cargo.toml') }}
          restore-keys: |
            ${{ runner.os }}-cargo-registry-

      # Step 5: Build all crates in release mode.
      #   `--release` selects the `[profile.release]` section from Cargo.toml.
      #   `--workspace` builds every crate: kvm-core, kvm-master, kvm-client,
      #   kvm-web-bridge.
      #   Platform-gated code (Windows hooks, X11 calls, CoreGraphics calls)
      #   is automatically included or excluded by the Rust compiler based on
      #   the host/target OS.
      - name: cargo build --release --workspace
        run: cargo build --manifest-path src/Cargo.toml --release --workspace

      # Step 6: Collect binaries into a staging directory.
      #   We create a folder named after the target platform and copy the three
      #   application binaries into it. This makes packaging straightforward.
      #   The `${{ matrix.binary_suffix }}` variable is `.exe` on Windows and
      #   empty on Linux/macOS.
      - name: Stage release binaries
        run: |
          # Create the staging directory. The folder name encodes the version
          # tag and platform so the archive is self-identifying.
          STAGING="kvm-over-ip-${{ github.ref_name }}-${{ matrix.target_name }}"
          mkdir -p "$STAGING"

          # Copy each application binary into the staging folder.
          cp "src/target/release/kvm-master${{ matrix.binary_suffix }}"     "$STAGING/"
          cp "src/target/release/kvm-client${{ matrix.binary_suffix }}"     "$STAGING/"
          cp "src/target/release/kvm-web-bridge${{ matrix.binary_suffix }}" "$STAGING/"

          # Copy project documentation so the archive is self-contained.
          cp README.md "$STAGING/" 2>/dev/null || true

          # Record the staging directory path for the next step.
          echo "STAGING=$STAGING" >> "$GITHUB_ENV"

      # Step 7: Create a compressed archive of the staging directory.
      #   Windows → ZIP (the most familiar archive format for Windows users).
      #   Linux/macOS → .tar.gz (standard Unix archive with gzip compression).
      - name: Create archive (tar.gz – Linux/macOS)
        if: matrix.archive_ext == 'tar.gz'
        # $STAGING was written to $GITHUB_ENV by the "Stage release binaries"
        # step and is available as a regular shell environment variable here.
        run: |
          tar -czf "${STAGING}.tar.gz" "${STAGING}"
          echo "ARCHIVE=${STAGING}.tar.gz" >> "$GITHUB_ENV"

      - name: Create archive (ZIP – Windows)
        if: matrix.archive_ext == 'zip'
        # PowerShell's Compress-Archive is available on Windows runners.
        # We pass the staging directory name through a bash variable (STAGING)
        # which was written to $GITHUB_ENV by the previous step. On Windows
        # the bash shell reads $GITHUB_ENV just like on Linux/macOS, so
        # $STAGING is available as a regular bash variable here.
        shell: bash
        run: |
          # $STAGING is the value written by the "Stage release binaries" step.
          ARCHIVE="${STAGING}.zip"
          powershell -Command "Compress-Archive -Path '${STAGING}' -DestinationPath '${ARCHIVE}'"
          echo "ARCHIVE=${ARCHIVE}" >> "$GITHUB_ENV"

      # Step 8: Upload the archive as a workflow artifact so the
      # `create-github-release` job can download and attach it.
      # Artifacts are stored by GitHub for the duration of the workflow run.
      - name: Upload binary archive as workflow artifact
        uses: actions/upload-artifact@v4
        with:
          # Unique artifact name per platform so they do not overwrite each other.
          name: release-${{ matrix.target_name }}
          path: ${{ env.ARCHIVE }}
          # If the upload fails (e.g., staging directory is empty) the job
          # fails loudly rather than silently producing an empty release.
          if-no-files-found: error

  # ---------------------------------------------------------------------------
  # JOB: create-github-release
  # ---------------------------------------------------------------------------
  # Downloads all three platform archives from the previous job and creates
  # a GitHub Release, attaching the archives as release assets.
  #
  # Why a separate job?
  #   The three build jobs run in parallel. This final job uses `needs` to
  #   wait for all three to complete successfully before creating the release.
  #   This prevents a partial release (e.g., only Windows binaries) from
  #   appearing if one platform build fails.
  # ---------------------------------------------------------------------------
  create-github-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    # Only run after ALL three build jobs have completed successfully.
    needs: build-release-binaries

    steps:
      - name: Check out repository (for changelog context)
        uses: actions/checkout@v4
        with:
          # Fetch the full git history so that the changelog generator can
          # compare commits between the new tag and the previous tag.
          fetch-depth: 0

      # Download all three platform archives produced by the build jobs.
      #   `pattern: release-*` matches all three artifact names:
      #     release-linux-x86_64
      #     release-windows-x86_64
      #     release-macos-aarch64
      #   `merge-multiple: true` places all files in a single `dist/` directory.
      - name: Download all platform archives
        uses: actions/download-artifact@v4
        with:
          pattern: release-*
          path: dist/
          merge-multiple: true

      # List the downloaded files for verification in the workflow log.
      - name: List release assets
        run: ls -lh dist/

      # Generate a changelog from git commits between this tag and the
      # previous one. The `softprops/action-gh-release` action does this
      # automatically when `generate_release_notes: true` is set.
      #
      # What `softprops/action-gh-release` does:
      #   - Creates a GitHub Release for the tag that triggered this workflow.
      #   - Sets the release title to the tag name (e.g., "v1.2.3").
      #   - Generates release notes from commit messages since the last tag.
      #   - Uploads every file matching `dist/*` as a release asset.
      #   - Marks the release as a "pre-release" if the tag contains a
      #     pre-release suffix (e.g., v1.0.0-beta.1).
      - name: Create GitHub Release and upload assets
        uses: softprops/action-gh-release@v2
        with:
          # Auto-generate release notes from commit messages.
          generate_release_notes: true
          # A header prepended to the auto-generated notes.
          body: |
            ## KVM-Over-IP ${{ github.ref_name }}

            ### Downloads

            | Platform      | Archive                                                    |
            |---------------|------------------------------------------------------------|
            | Windows x64   | `kvm-over-ip-${{ github.ref_name }}-windows-x86_64.zip`   |
            | Linux x64     | `kvm-over-ip-${{ github.ref_name }}-linux-x86_64.tar.gz`  |
            | macOS arm64   | `kvm-over-ip-${{ github.ref_name }}-macos-aarch64.tar.gz` |

            ### Installation

            1. Download the archive for your operating system.
            2. Extract the contents.
            3. Run `kvm-master` on the machine that has the keyboard/mouse.
            4. Run `kvm-client` on each remote machine.
            5. Optionally run `kvm-web-bridge` to enable browser-based access.

            See `README.md` inside the archive for full setup instructions.

            ---
            *Auto-generated release notes from commits:*
          # Upload all archives from the dist/ directory.
          files: dist/*
          # Fail loudly if the tag ref is not a proper version tag, rather
          # than silently creating a malformed release.
          fail_on_unmatched_files: true
